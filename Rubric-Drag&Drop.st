'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.379852 pm'!!RubTextEditor methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 20:38'!dropSelection: event	"Let me process drop for D&D"	"First to judge the drop postion,then cut old , past and selection"	(self paragraph selectionContainsPoint: event cursorPoint)		ifTrue: [ ^ self ].	Sensor controlKeyPressed		ifFalse: [ self dropWithoutSelection: event ]		ifTrue: [ self dropWithSelection: event ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.380852 pm'!!RubTextEditor methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 21:47'!mouseDownOnSelectedText: event	"Create dragSelection  action for the event  LB added"	event hand		waitForClicksOrDrag: self		event: event		selectors:			{nil.			nil.			nil.			#dragSelection:}		threshold: 5! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.380852 pm'!!RubTextEditor methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 21:04'!transformedFrom: owner	^ textArea transformedFrom: owner! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.380852 pm'!!RubTextEditor methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 21:40'!dropWithoutSelection: event	"Let me process drop for D&D ctrl key not pressed"	"First to judge the drop postion,then cut old , past and selection"	| currentStartB newPosition selectedText start stop |	currentStartB := self paragraph characterBlockAtPoint: event cursorPoint.	newPosition := currentStartB stringIndex.	start := self startIndex.	stop := self stopIndex.	selectedText := self selection.	self editingState undoManager openRecordGroup.	self textArea changed.	currentStartB < self startBlock		ifTrue: [ 			self paragraph replaceFrom: start to: stop - 1 with: self nullText.			self editingState				redoArray:					{textArea.					#redoTypeIn:interval:.					{self nullText.					1 to: -1}}				undoArray:					{textArea.					#undoTypeIn:interval:.					{self nullText.					newPosition + selectedText size to: newPosition - 1}}.			self paragraph replaceFrom: newPosition to: newPosition - 1 with: selectedText.			self editingState				redoArray:					{textArea.					#redoTypeIn:interval:.					{self nullText.					1 to: 1}}				undoArray:					{textArea.					#undoTypeIn:interval:.					{selectedText.					start + selectedText size to: start + selectedText size - 1}}.			self selectFrom: newPosition to: newPosition + selectedText size - 1 ].	currentStartB > self stopBlock		ifTrue: [ 			self paragraph replaceFrom: newPosition to: newPosition - 1 with: selectedText.			self editingState				redoArray:					{textArea.					#redoTypeIn:interval:.					{self nullText.					1 to: 1}}				undoArray:					{textArea.					#undoTypeIn:interval:.					{self nullText.					newPosition to: newPosition + selectedText size - 1}}.			self paragraph replaceFrom: start to: stop - 1 with: self nullText.			self editingState				redoArray:					{textArea.					#redoTypeIn:interval:.					{self nullText.					1 to: -1}}				undoArray:					{textArea.					#undoTypeIn:interval:.					{selectedText.					start to: start - 1}}.			self selectFrom: newPosition - selectedText size to: newPosition - 1 ].	self editingState undoManager closeRecordGroup.	self flash! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.381852 pm'!!RubTextEditor methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 21:43'!startBlock	^ self editingState pointBlock min: self editingState markBlock! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.382852 pm'!!RubTextEditor methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 21:39'!dropWithSelection: event	"Let me process drop for D&D ctrl key pressed"	"First to judge the drop postion,then cut old , past and selection"	| currentStartB newPosition selectedText |	currentStartB := self paragraph characterBlockAtPoint: event cursorPoint.	newPosition := currentStartB stringIndex.	selectedText := self selection.	self textArea changed.	self editingState undoManager openRecordGroup.	self paragraph replaceFrom: newPosition to: newPosition - 1 with: selectedText.	self editingState		redoArray:			{textArea.			#redoTypeIn:interval:.			{self nullText.			1 to: -1}}		undoArray:			{textArea.			#undoTypeIn:interval:.			{self nullText.			newPosition to: newPosition + selectedText size - 1}}.	self editingState undoManager closeRecordGroup.	self		markIndex: newPosition;		pointIndex: newPosition + selectedText size.	self editingState previousInterval: self selectionInterval selection: self selection.	self selectFrom: newPosition to: newPosition + selectedText size - 1.	self flash! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.382852 pm'!!RubTextEditor methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 21:44'!stopBlock	^ self editingState pointBlock max: self editingState markBlock! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.383852 pm'!!RubTextEditor methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 20:39'!dragSelection: evt	"Second step for drag&drop LB, open dragMorph"	| draggedMorph ddm dragString dragSelection |	(dragString := dragSelection := self selection) ifNil: [ ^ self ].	dragSelection size > 8		ifTrue: [ dragString := (dragSelection copyFrom: 1 to: 8) , '....more.' ].	"aviod too long text draged. now draged in my pane, shoule be added in handMorph if another text pane"	draggedMorph := StringMorph contents: dragString.	draggedMorph color: Color white.	ddm := TransferMorph withPassenger: draggedMorph from: self textArea.	ddm dragTransferType: #dragSelectionPlus.	[ 	ddm position: evt hand position.	evt hand grabMorph: ddm ]		ensure: [ 			Cursor normal show.			evt hand releaseMouseFocus: self ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.383852 pm'!!RubAbstractTextArea methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 19:08'!dragSelection: evt	"Second step for drag&drop LB, open dragMorph"	| draggedMorph ddm dragString dragSelection |	(dragString := dragSelection := self selection) ifNil: [ ^ self ].	dragSelection size > 8		ifTrue: [ dragString := (dragSelection copyFrom: 1 to: 8) , '....more.' ].	"aviod too long text draged. now draged in my pane, shoule be added in handMorph if another text pane"	draggedMorph := StringMorph contents: dragString.	draggedMorph color: Color white.	ddm := TransferMorph withPassenger: draggedMorph from: self .	ddm dragTransferType: #dragSelectionPlus.	[ 	ddm position: evt hand position.	evt hand grabMorph: ddm ]		ensure: [ 			Cursor normal show.			evt hand releaseMouseFocus: self ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.383852 pm'!!RubAbstractTextArea methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 21:46'!wantsDroppedMorph: aMorph event: anEvent	aMorph dragTransferType == #dragSelectionPlus		ifFalse: [ ^ false ].	editor selection ifNotNil: [ ^ true  ].	^ false! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.384852 pm'!!RubAbstractTextArea methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 20:49'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto me."	self editor dropSelection: evt.	"third step  LB added"	self addMorphFront: aMorph fromWorldPosition: aMorph position	"Make a TextAnchor and install it in a run."! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.384852 pm'!!RubAbstractTextArea methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 21:02'!mouseDown: evt	"Make this TextMorph be the keyboard input focus, if it isn't  	already, and repond to the text selection gesture.	Changed to not take keyboard focus if an owner is a	PluggableTextMorph that doesn't want focus."	(evt yellowButtonPressed and: [ evt commandKeyPressed not ])		ifTrue: [ ^ self yellowButtonActivity: evt shiftPressed ].	"First check for option (menu) click"	(self paragraph click: evt for: self model controller: self)		ifTrue: [ 			self click: evt.			evt hand releaseKeyboardFocus: self.			^ self ].	(evt yellowButtonChanged or: [ evt commandKeyPressed ])		ifTrue: [ 			(self yellowButtonActivity: evt shiftPressed)				ifTrue: [ ^ self ] ].	"no matter what, if shift is pressed extend the selection"	evt shiftPressed		ifTrue: [ ^ self mouseMove: evt ].	(self readOnly or: [ self hasFocus or: [ self editor hasSelection not ] ])		ifTrue: [ 			| selectors |			self scrollPivot: evt hand position.			selectors := Array				with: #click:				with: #doubleClick:				with: nil				with: nil.			evt hand				waitForClicksOrDrag: self				event: evt				selectors: selectors				threshold: 5 ].	self hasKeyboardFocus		ifFalse: [ self takeKeyboardFocus ].	(self paragraph selectionContainsPoint: evt cursorPoint)		ifTrue: [ self editor mouseDownOnSelectedText: evt ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60498] on 3 June 2017 at 1:19:00.385852 pm'!!RubParagraph methodsFor: '*Rubric-Drag&Drop' stamp: 'LB 6/26/2015 18:59'!selectionContainsPoint: aPoint	"return whether the current selection contains the given point"	^ self selectionRects anySatisfy: [ :rect| rect containsPoint: aPoint ]! !